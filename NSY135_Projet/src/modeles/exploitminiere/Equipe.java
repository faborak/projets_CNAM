package modeles.exploitminiere;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Transient;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Entity
public class Equipe {

	@Id
	@GeneratedValue
	@Column(name = "id_equipe")
	private Integer id_equipe;
	public void setId(Integer i) {id_equipe = i;}
	public Integer getId() {return id_equipe;}
	
	@Column
	String nom;
	public void setNom(String n) {nom = n;}
	public String getNom() {return nom;}
	
	/**
	 * pour la sauvegarde en cascade, on utilise JPA (javax.peristance) et non pas hibernate
	 * Toutes les cascades sont sous la responsabilité de l'objet équipe
	 * 
	 */
    @ManyToOne (fetch=FetchType.LAZY, cascade=CascadeType.PERSIST)
	@JoinColumn (name="id_gisement")
	private Gisement gisementEnCours;
	public void setGisementEnCours(Gisement g) {gisementEnCours = g;}
	public Gisement getGisementEnCours() {return gisementEnCours;}
	
	/**
	 * Le responsable de l'équipe.
	 * Hypothese : plusieurs equipes peuvent encadrees par un seul Humain    
	 */
	@ManyToOne (fetch=FetchType.LAZY, cascade=CascadeType.PERSIST)
	@JoinColumn (name="id_ouvrier_responsable")
	private Ouvrier manager;
	public void setManager(Ouvrier o) {manager = o;}
	public Ouvrier getManager() {return manager;}
	
	/**
	 * Les membres de l'équipe.  
	 */
    @OneToMany(mappedBy="equipe", cascade=CascadeType.PERSIST)
	private Set<Ouvrier> personnel = new HashSet<Ouvrier>();
	public void addPersonnel(Ouvrier f) {f.setEquipe(this); personnel.add(f);}
	public Set<Ouvrier> getPersonnel() {return personnel;}
	
	/**
	 * Utilisé pour les calculs de gestion
	 * applique getCout() sur les Ouvriers, qu'ils soient humains ou robots,
	 * Et renvoie la somme totale.
	 */
	@Transient
	public double cout;
	public double getCout() {return cout;}
	public void calculCout() {
		for (Ouvrier ouvrier : personnel) {
			   ouvrier.calculCout();
			   cout = cout + ouvrier.getCout();
		}
	}
}
