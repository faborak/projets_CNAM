package modeles.exploitminiere;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Transient;

@Entity
@PrimaryKeyJoinColumn(name="id_ouvrier")
public class Robot extends Ouvrier {

	@Column
	Integer numero_serie;
	public void setNumero_serie(Integer ns) {numero_serie = ns;}
	public Integer getNumero_serie() {return numero_serie;}
	
	/**
	 * Lien à la colonne Modèle 
	 * le chargement n'est pas Lazy pour permettre le calcul du coût en gestion.
	 * Le modèle de chaque Robot est donc chargé avec le robot.
	 */
	@ManyToOne(cascade=CascadeType.PERSIST)
	@JoinColumn (name="modele")
	private Modele modele;
	public void setModele(Modele m) {modele = m;}
	public Modele getModele() {return modele;} 
	
	/**
	 * Le cout du robot, objet transcient utilisé pour le calcul du coût.
	 */
	@Transient
	public double cout;
	public double getCout() {return cout;}
	public void calculCout() {
		Date d2 = new Date();
		final long MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24; 
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		String test = super.getDate_affectation() + " 00:00";
		Date d1 = null;
		try {
			d1 = sdf.parse(test);
		} catch (ParseException e) {
			e.printStackTrace();
		}	
		long delta = Math.abs(d2.getTime() - d1.getTime());
		cout = (Math.floor(this.getModele().getCout_exploitation_mensuel() * 0.3546 * (delta/MILLISECONDS_PER_DAY)))/100;
	}
	
}
